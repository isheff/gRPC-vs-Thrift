{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (1.0.0-dev)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Bigstructure_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data BigStructureValue = BigStructureValue  { bigStructureValue_i :: P.Maybe I.Int64
  , bigStructureValue_b :: P.Maybe P.Bool
  , bigStructureValue_s :: P.Maybe LT.Text
  , bigStructureValue_y :: P.Maybe LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BigStructureValue where
  hashWithSalt salt record = salt   `H.hashWithSalt` bigStructureValue_i record   `H.hashWithSalt` bigStructureValue_b record   `H.hashWithSalt` bigStructureValue_s record   `H.hashWithSalt` bigStructureValue_y record  
instance QC.Arbitrary BigStructureValue where 
  arbitrary = M.liftM BigStructureValue (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BigStructureValue = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BigStructureValue{bigStructureValue_i = bigStructureValue_i obj} then P.Nothing else P.Just $ default_BigStructureValue{bigStructureValue_i = bigStructureValue_i obj}
    , if obj == default_BigStructureValue{bigStructureValue_b = bigStructureValue_b obj} then P.Nothing else P.Just $ default_BigStructureValue{bigStructureValue_b = bigStructureValue_b obj}
    , if obj == default_BigStructureValue{bigStructureValue_s = bigStructureValue_s obj} then P.Nothing else P.Just $ default_BigStructureValue{bigStructureValue_s = bigStructureValue_s obj}
    , if obj == default_BigStructureValue{bigStructureValue_y = bigStructureValue_y obj} then P.Nothing else P.Just $ default_BigStructureValue{bigStructureValue_y = bigStructureValue_y obj}
    ]
from_BigStructureValue :: BigStructureValue -> T.ThriftVal
from_BigStructureValue record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("i",T.TI64 _v2))) <$> bigStructureValue_i record
  , (\_v2 -> (2, ("b",T.TBool _v2))) <$> bigStructureValue_b record
  , (\_v2 -> (3, ("s",T.TString $ E.encodeUtf8 _v2))) <$> bigStructureValue_s record
  , (\_v2 -> (4, ("y",T.TBinary _v2))) <$> bigStructureValue_y record
  ]
write_BigStructureValue :: T.Protocol p => p -> BigStructureValue -> P.IO ()
write_BigStructureValue oprot record = T.writeVal oprot $ from_BigStructureValue record
encode_BigStructureValue :: T.StatelessProtocol p => p -> BigStructureValue -> LBS.ByteString
encode_BigStructureValue oprot record = T.serializeVal oprot $ from_BigStructureValue record
to_BigStructureValue :: T.ThriftVal -> BigStructureValue
to_BigStructureValue (T.TStruct fields) = BigStructureValue{
  bigStructureValue_i = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI64 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  bigStructureValue_b = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TBool _val6 -> _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  bigStructureValue_s = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val7 -> E.decodeUtf8 _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  bigStructureValue_y = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TBinary _val8 -> _val8; T.TString _val8 -> _val8; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_BigStructureValue _ = P.error "not a struct"
read_BigStructureValue :: T.Protocol p => p -> P.IO BigStructureValue
read_BigStructureValue iprot = to_BigStructureValue <$> T.readVal iprot (T.T_STRUCT typemap_BigStructureValue)
decode_BigStructureValue :: T.StatelessProtocol p => p -> LBS.ByteString -> BigStructureValue
decode_BigStructureValue iprot bs = to_BigStructureValue $ T.deserializeVal iprot (T.T_STRUCT typemap_BigStructureValue) bs
typemap_BigStructureValue :: T.TypeMap
typemap_BigStructureValue = Map.fromList [(1,("i",T.T_I64)),(2,("b",T.T_BOOL)),(3,("s",T.T_STRING)),(4,("y",T.T_BINARY))]
default_BigStructureValue :: BigStructureValue
default_BigStructureValue = BigStructureValue{
  bigStructureValue_i = P.Nothing,
  bigStructureValue_b = P.Nothing,
  bigStructureValue_s = P.Nothing,
  bigStructureValue_y = P.Nothing}
data BigStructure = BigStructure  { bigStructure_v :: BigStructureValue
  , bigStructure_children :: (Vector.Vector BigStructure)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BigStructure where
  hashWithSalt salt record = salt   `H.hashWithSalt` bigStructure_v record   `H.hashWithSalt` bigStructure_children record  
instance QC.Arbitrary BigStructure where 
  arbitrary = M.liftM BigStructure (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BigStructure = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BigStructure{bigStructure_v = bigStructure_v obj} then P.Nothing else P.Just $ default_BigStructure{bigStructure_v = bigStructure_v obj}
    , if obj == default_BigStructure{bigStructure_children = bigStructure_children obj} then P.Nothing else P.Just $ default_BigStructure{bigStructure_children = bigStructure_children obj}
    ]
from_BigStructure :: BigStructure -> T.ThriftVal
from_BigStructure record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11 -> P.Just (1, ("v",from_BigStructureValue _v11))) $ bigStructure_v record
  , (\_v11 -> P.Just (2, ("children",T.TList (T.T_STRUCT typemap_BigStructure) $ P.map (\_v13 -> from_BigStructure _v13) $ Vector.toList _v11))) $ bigStructure_children record
  ]
write_BigStructure :: T.Protocol p => p -> BigStructure -> P.IO ()
write_BigStructure oprot record = T.writeVal oprot $ from_BigStructure record
encode_BigStructure :: T.StatelessProtocol p => p -> BigStructure -> LBS.ByteString
encode_BigStructure oprot record = T.serializeVal oprot $ from_BigStructure record
to_BigStructure :: T.ThriftVal -> BigStructure
to_BigStructure (T.TStruct fields) = BigStructure{
  bigStructure_v = P.maybe (bigStructure_v default_BigStructure) (\(_,_val15) -> (case _val15 of {T.TStruct _val16 -> (to_BigStructureValue (T.TStruct _val16)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  bigStructure_children = P.maybe (bigStructure_children default_BigStructure) (\(_,_val15) -> (case _val15 of {T.TList _ _val17 -> (Vector.fromList $ P.map (\_v18 -> (case _v18 of {T.TStruct _val19 -> (to_BigStructure (T.TStruct _val19)); _ -> P.error "wrong type"})) _val17); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BigStructure _ = P.error "not a struct"
read_BigStructure :: T.Protocol p => p -> P.IO BigStructure
read_BigStructure iprot = to_BigStructure <$> T.readVal iprot (T.T_STRUCT typemap_BigStructure)
decode_BigStructure :: T.StatelessProtocol p => p -> LBS.ByteString -> BigStructure
decode_BigStructure iprot bs = to_BigStructure $ T.deserializeVal iprot (T.T_STRUCT typemap_BigStructure) bs
typemap_BigStructure :: T.TypeMap
typemap_BigStructure = Map.fromList [(1,("v",(T.T_STRUCT typemap_BigStructureValue))),(2,("children",(T.T_LIST (T.T_STRUCT typemap_BigStructure))))]
default_BigStructure :: BigStructure
default_BigStructure = BigStructure{
  bigStructure_v = default_BigStructureValue,
  bigStructure_children = Vector.empty}
